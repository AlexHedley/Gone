{
open System
open System.Globalization
open FSharp.Text.Lexing


let mutable lineNo = 1
let mutable lastLineComment = 1

let newline (lexbuf: LexBuffer<_>) =
  lineNo <- lineNo + 1
  lexbuf.StartPos <- lexbuf.StartPos.NextLine

let lexeme (lexbuf: LexBuffer<_>) =
  LexBuffer<_>.LexemeString (lexbuf)

let setInitialPos (lexbuf : LexBuffer<_>) filename = 
  lexbuf.EndPos <- { pos_bol = 0; pos_fname=filename; pos_cnum=0; pos_lnum=1 }

}

// Regular expressions
let digit = ['0'-'9']
let whitespace = [' ' '\t' ]
let newline = ('\n' | '\r' '\n')

rule token = parse
| whitespace	{ token lexbuf }
| newline		{ newline lexbuf; token lexbuf }
| "//"			{ singleLineComment lexbuf; token lexbuf }
| "/*"			{ multiLineComment lexbuf; token lexbuf }
| "use"whitespace*"<"[^'>']+">"			{ USE (lexeme lexbuf) }
| "function"	{ FUNCTION }
| "module"		{ MODULE }
| "if"			{ IF }
| "else"		{ ELSE }
| "for"			{ FOR }
| "true"		{ BOOL(true) }
| "false"		{ BOOL(false) }
| "="			{ EQ }
| "&&"			{ AND }
| "||"			{ OR }
| "<"			{ LT }
| ">"			{ GT }
| "<="			{ LTEQ }
| ">="			{ GTEQ }
| "=="			{ EQEQ }
| "!="			{ NEQ }
| ","			{ COMMA }
| ";"			{ SEMI }
| ":"			{ COLON }
| "%"			{ PERCENT }
| "#"			{ HASH }
| "*"			{ MUL }
| "/"			{ DIV }
| "+"			{ PLUS }
| "-"			{ MINUS }
| "!"			{ BANG }
| "?"			{ QUESTION }
| "{"			{ LCURLY }
| "}"			{ RCURLY }
| "["			{ LBRACKET }
| "]"			{ RBRACKET }
| "("			{ LPAREN }
| ")"			{ RPAREN }
| '"' [^'"']* '"'	{ let s = lexeme lexbuf in STRING(s.Substring (1, s.Length - 2)) }
| ['_''$''a'-'z''A'-'Z']['_''$''a'-'z''A'-'Z''0'-'9']*	{ ID(lexeme lexbuf) }
| digit*['_''$''a'-'z''A'-'Z']['_''$''a'-'z''A'-'Z''0'-'9']*	{ ID(lexeme lexbuf) }
| ((digit+'.'digit+)|('.'digit+)|(digit+))(['e''E']digit+)? whitespace* '"' { FLOAT (let s = lexeme lexbuf in (Double.Parse(s.Substring (0, s.Length-1), CultureInfo.InvariantCulture))*25.4) }
| digit*('.'digit+)?(['e''E']digit+)?   { FLOAT (Double.Parse(lexeme lexbuf, CultureInfo.InvariantCulture)) }
| eof   		{ EOF }

and singleLineComment = parse
| eof			{ () }
| newline		{ newline lexbuf; () }
| _				{ singleLineComment lexbuf }

and multiLineComment = parse
| "*/" | eof	{ () }
| newline		{ newline lexbuf; multiLineComment lexbuf }
| _				{ multiLineComment lexbuf }
